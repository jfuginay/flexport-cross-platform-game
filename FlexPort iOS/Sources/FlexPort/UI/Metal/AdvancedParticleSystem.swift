import Metal\nimport MetalKit\nimport simd\nimport GameplayKit\n\n/// Advanced particle system for ship wakes, weather effects, and visual enhancements\nclass AdvancedParticleSystem {\n    \n    // Metal resources\n    private var device: MTLDevice\n    private var library: MTLLibrary\n    private var commandQueue: MTLCommandQueue\n    \n    // Compute pipeline states\n    private var particleUpdatePipeline: MTLComputePipelineState!\n    private var particleRenderPipeline: MTLRenderPipelineState!\n    \n    // Buffers\n    private var particleBuffer: MTLBuffer!\n    private var particleCountBuffer: MTLBuffer!\n    private var emitterBuffer: MTLBuffer!\n    private var uniformBuffer: MTLBuffer!\n    \n    // Textures\n    private var particleTextures: [ParticleType: MTLTexture] = [:]\n    \n    // System state\n    private var maxParticles: Int\n    private var activeEmitters: [ParticleEmitter] = []\n    private var particleCount: Int = 0\n    \n    // Performance tracking\n    private var lastUpdateTime: CFTimeInterval = 0\n    private var deltaTime: Float = 0\n    \n    init(device: MTLDevice, maxParticles: Int = 10000) {\n        self.device = device\n        self.maxParticles = maxParticles\n        \n        guard let library = device.makeDefaultLibrary(),\n              let commandQueue = device.makeCommandQueue() else {\n            fatalError(\"Failed to create Metal resources\")\n        }\n        \n        self.library = library\n        self.commandQueue = commandQueue\n        \n        setupPipelines()\n        setupBuffers()\n        loadParticleTextures()\n        createDefaultEmitters()\n    }\n    \n    // MARK: - Setup\n    \n    private func setupPipelines() {\n        // Compute pipeline for particle updates\n        guard let updateFunction = library.makeFunction(name: \"updateParticles\") else {\n            fatalError(\"Failed to create particle update function\")\n        }\n        \n        do {\n            particleUpdatePipeline = try device.makeComputePipelineState(function: updateFunction)\n        } catch {\n            fatalError(\"Failed to create particle update pipeline: \\(error)\")\n        }\n        \n        // Render pipeline for particle rendering\n        let renderDescriptor = MTLRenderPipelineDescriptor()\n        renderDescriptor.vertexFunction = library.makeFunction(name: \"particleVertexShader\")\n        renderDescriptor.fragmentFunction = library.makeFunction(name: \"particleFragmentShader\")\n        renderDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm\n        \n        // Enable alpha blending\n        renderDescriptor.colorAttachments[0].isBlendingEnabled = true\n        renderDescriptor.colorAttachments[0].sourceRGBBlendFactor = .sourceAlpha\n        renderDescriptor.colorAttachments[0].destinationRGBBlendFactor = .oneMinusSourceAlpha\n        \n        do {\n            particleRenderPipeline = try device.makeRenderPipelineState(descriptor: renderDescriptor)\n        } catch {\n            fatalError(\"Failed to create particle render pipeline: \\(error)\")\n        }\n    }\n    \n    private func setupBuffers() {\n        // Particle data buffer\n        let particleSize = MemoryLayout<Particle>.stride\n        particleBuffer = device.makeBuffer(length: particleSize * maxParticles, options: .storageModeShared)\n        \n        // Particle count buffer\n        particleCountBuffer = device.makeBuffer(length: MemoryLayout<UInt32>.stride, options: .storageModeShared)\n        \n        // Emitter buffer\n        let maxEmitters = 100\n        emitterBuffer = device.makeBuffer(length: MemoryLayout<EmitterData>.stride * maxEmitters, options: .storageModeShared)\n        \n        // Uniform buffer\n        uniformBuffer = device.makeBuffer(length: MemoryLayout<ParticleUniforms>.stride, options: .storageModeShared)\n    }\n    \n    private func loadParticleTextures() {\n        // Load different particle textures\n        particleTextures[.water] = createWaterParticleTexture()\n        particleTextures[.smoke] = createSmokeParticleTexture()\n        particleTextures[.steam] = createSteamParticleTexture()\n        particleTextures[.spark] = createSparkParticleTexture()\n        particleTextures[.foam] = createFoamParticleTexture()\n        particleTextures[.wake] = createWakeParticleTexture()\n    }\n    \n    private func createDefaultEmitters() {\n        // Create some default emitters for testing\n        let shipWakeEmitter = ParticleEmitter(\n            id: UUID(),\n            type: .wake,\n            position: SIMD3<Float>(0, 0, 0),\n            emissionRate: 50,\n            particleLifetime: 3.0,\n            initialVelocity: SIMD3<Float>(0, 0, -5),\n            velocityVariation: SIMD3<Float>(2, 1, 1),\n            size: 0.5,\n            sizeVariation: 0.2,\n            color: SIMD4<Float>(1, 1, 1, 0.8),\n            colorVariation: SIMD4<Float>(0.1, 0.1, 0.1, 0.2)\n        )\n        \n        activeEmitters.append(shipWakeEmitter)\n    }\n    \n    // MARK: - Particle System Management\n    \n    func addEmitter(_ emitter: ParticleEmitter) {\n        activeEmitters.append(emitter)\n    }\n    \n    func removeEmitter(id: UUID) {\n        activeEmitters.removeAll { $0.id == id }\n    }\n    \n    func createShipWake(at position: SIMD3<Float>, velocity: SIMD3<Float>) -> UUID {\n        let emitter = ParticleEmitter(\n            id: UUID(),\n            type: .wake,\n            position: position,\n            emissionRate: 30,\n            particleLifetime: 2.5,\n            initialVelocity: velocity * -0.3, // Wake trails behind\n            velocityVariation: SIMD3<Float>(1, 0.5, 1),\n            size: 0.8,\n            sizeVariation: 0.3,\n            color: SIMD4<Float>(0.9, 0.95, 1.0, 0.7),\n            colorVariation: SIMD4<Float>(0.1, 0.1, 0.1, 0.3)\n        )\n        \n        addEmitter(emitter)\n        return emitter.id\n    }\n    \n    func createPortSmokeStack(at position: SIMD3<Float>) -> UUID {\n        let emitter = ParticleEmitter(\n            id: UUID(),\n            type: .smoke,\n            position: position,\n            emissionRate: 20,\n            particleLifetime: 8.0,\n            initialVelocity: SIMD3<Float>(0, 3, 0),\n            velocityVariation: SIMD3<Float>(0.5, 1, 0.5),\n            size: 1.2,\n            sizeVariation: 0.5,\n            color: SIMD4<Float>(0.3, 0.3, 0.3, 0.6),\n            colorVariation: SIMD4<Float>(0.2, 0.2, 0.2, 0.3)\n        )\n        \n        addEmitter(emitter)\n        return emitter.id\n    }\n    \n    func createWeatherEffect(_ type: WeatherType, intensity: Float) {\n        switch type {\n        case .rain:\n            createRainEffect(intensity: intensity)\n        case .fog:\n            createFogEffect(intensity: intensity)\n        case .storm:\n            createStormEffect(intensity: intensity)\n        }\n    }\n    \n    private func createRainEffect(intensity: Float) {\n        for i in 0..<Int(intensity * 10) {\n            let emitter = ParticleEmitter(\n                id: UUID(),\n                type: .water,\n                position: SIMD3<Float>(\n                    Float.random(in: -100...100),\n                    50,\n                    Float.random(in: -100...100)\n                ),\n                emissionRate: 100,\n                particleLifetime: 3.0,\n                initialVelocity: SIMD3<Float>(0, -20, 0),\n                velocityVariation: SIMD3<Float>(2, 2, 2),\n                size: 0.1,\n                sizeVariation: 0.05,\n                color: SIMD4<Float>(0.7, 0.8, 1.0, 0.8),\n                colorVariation: SIMD4<Float>(0.1, 0.1, 0.1, 0.2)\n            )\n            \n            addEmitter(emitter)\n        }\n    }\n    \n    private func createFogEffect(intensity: Float) {\n        for i in 0..<Int(intensity * 5) {\n            let emitter = ParticleEmitter(\n                id: UUID(),\n                type: .steam,\n                position: SIMD3<Float>(\n                    Float.random(in: -50...50),\n                    Float.random(in: 0...10),\n                    Float.random(in: -50...50)\n                ),\n                emissionRate: 10,\n                particleLifetime: 15.0,\n                initialVelocity: SIMD3<Float>(0, 0.5, 0),\n                velocityVariation: SIMD3<Float>(0.5, 0.5, 0.5),\n                size: 5.0,\n                sizeVariation: 2.0,\n                color: SIMD4<Float>(0.9, 0.9, 0.9, 0.3),\n                colorVariation: SIMD4<Float>(0.1, 0.1, 0.1, 0.1)\n            )\n            \n            addEmitter(emitter)\n        }\n    }\n    \n    private func createStormEffect(intensity: Float) {\n        // Lightning sparks\n        for i in 0..<Int(intensity * 3) {\n            let emitter = ParticleEmitter(\n                id: UUID(),\n                type: .spark,\n                position: SIMD3<Float>(\n                    Float.random(in: -200...200),\n                    Float.random(in: 30...60),\n                    Float.random(in: -200...200)\n                ),\n                emissionRate: 200,\n                particleLifetime: 0.5,\n                initialVelocity: SIMD3<Float>(0, -10, 0),\n                velocityVariation: SIMD3<Float>(10, 5, 10),\n                size: 0.3,\n                sizeVariation: 0.2,\n                color: SIMD4<Float>(1.0, 1.0, 0.8, 1.0),\n                colorVariation: SIMD4<Float>(0.2, 0.2, 0.2, 0.3)\n            )\n            \n            addEmitter(emitter)\n        }\n    }\n    \n    // MARK: - Update and Rendering\n    \n    func update(deltaTime: Float, cameraPosition: SIMD3<Float>, viewMatrix: matrix_float4x4, projectionMatrix: matrix_float4x4) {\n        guard particleCount > 0 || !activeEmitters.isEmpty else { return }\n        \n        self.deltaTime = deltaTime\n        \n        let commandBuffer = commandQueue.makeCommandBuffer()!\n        let computeEncoder = commandBuffer.makeComputeCommandEncoder()!\n        \n        // Update uniforms\n        updateUniforms(cameraPosition: cameraPosition, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix)\n        \n        // Update particles using compute shader\n        computeEncoder.setComputePipelineState(particleUpdatePipeline)\n        computeEncoder.setBuffer(particleBuffer, offset: 0, index: 0)\n        computeEncoder.setBuffer(particleCountBuffer, offset: 0, index: 1)\n        computeEncoder.setBuffer(emitterBuffer, offset: 0, index: 2)\n        computeEncoder.setBuffer(uniformBuffer, offset: 0, index: 3)\n        \n        // Update emitter data\n        updateEmitterData()\n        \n        let threadsPerGroup = MTLSize(width: 64, height: 1, depth: 1)\n        let numThreadgroups = MTLSize(\n            width: (maxParticles + threadsPerGroup.width - 1) / threadsPerGroup.width,\n            height: 1,\n            depth: 1\n        )\n        \n        computeEncoder.dispatchThreadgroups(numThreadgroups, threadsPerThreadgroup: threadsPerGroup)\n        computeEncoder.endEncoding()\n        \n        commandBuffer.commit()\n        commandBuffer.waitUntilCompleted()\n        \n        // Read back particle count\n        if let countPointer = particleCountBuffer.contents().bindMemory(to: UInt32.self, capacity: 1) {\n            particleCount = Int(countPointer.pointee)\n        }\n    }\n    \n    func render(renderEncoder: MTLRenderCommandEncoder) {\n        guard particleCount > 0 else { return }\n        \n        renderEncoder.setRenderPipelineState(particleRenderPipeline)\n        renderEncoder.setVertexBuffer(particleBuffer, offset: 0, index: 0)\n        renderEncoder.setVertexBuffer(uniformBuffer, offset: 0, index: 1)\n        \n        // Render particles by type to group texture binding\n        var lastType: ParticleType?\n        \n        // Note: In a more advanced implementation, we would sort particles by type\n        // and render each group with the appropriate texture\n        \n        // For now, render all particles with a default texture\n        if let texture = particleTextures[.water] {\n            renderEncoder.setFragmentTexture(texture, index: 0)\n        }\n        \n        renderEncoder.drawPrimitives(type: .point, vertexStart: 0, vertexCount: particleCount)\n    }\n    \n    private func updateUniforms(cameraPosition: SIMD3<Float>, viewMatrix: matrix_float4x4, projectionMatrix: matrix_float4x4) {\n        let uniforms = ParticleUniforms(\n            viewMatrix: viewMatrix,\n            projectionMatrix: projectionMatrix,\n            cameraPosition: cameraPosition,\n            deltaTime: deltaTime,\n            time: Float(CACurrentMediaTime())\n        )\n        \n        uniformBuffer.contents().copyMemory(from: [uniforms], byteCount: MemoryLayout<ParticleUniforms>.stride)\n    }\n    \n    private func updateEmitterData() {\n        let emitterData = activeEmitters.map { emitter in\n            EmitterData(\n                position: emitter.position,\n                velocity: emitter.initialVelocity,\n                emissionRate: emitter.emissionRate,\n                particleLifetime: emitter.particleLifetime,\n                size: emitter.size,\n                color: emitter.color,\n                type: UInt32(emitter.type.rawValue),\n                active: emitter.isActive ? 1 : 0\n            )\n        }\n        \n        if !emitterData.isEmpty {\n            emitterBuffer.contents().copyMemory(\n                from: emitterData,\n                byteCount: emitterData.count * MemoryLayout<EmitterData>.stride\n            )\n        }\n    }\n    \n    // MARK: - Texture Creation\n    \n    private func createWaterParticleTexture() -> MTLTexture {\n        return createRadialGradientTexture(centerColor: SIMD4<Float>(0.7, 0.8, 1.0, 0.8), edgeColor: SIMD4<Float>(0.5, 0.6, 0.8, 0.0))\n    }\n    \n    private func createSmokeParticleTexture() -> MTLTexture {\n        return createCloudTexture(color: SIMD4<Float>(0.4, 0.4, 0.4, 0.6))\n    }\n    \n    private func createSteamParticleTexture() -> MTLTexture {\n        return createCloudTexture(color: SIMD4<Float>(0.9, 0.9, 0.9, 0.4))\n    }\n    \n    private func createSparkParticleTexture() -> MTLTexture {\n        return createStarTexture(color: SIMD4<Float>(1.0, 1.0, 0.8, 1.0))\n    }\n    \n    private func createFoamParticleTexture() -> MTLTexture {\n        return createFoamyTexture(color: SIMD4<Float>(1.0, 1.0, 1.0, 0.7))\n    }\n    \n    private func createWakeParticleTexture() -> MTLTexture {\n        return createWakeTexture(color: SIMD4<Float>(0.9, 0.95, 1.0, 0.6))\n    }\n    \n    private func createRadialGradientTexture(centerColor: SIMD4<Float>, edgeColor: SIMD4<Float>) -> MTLTexture {\n        let size = 64\n        let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(\n            pixelFormat: .rgba8Unorm,\n            width: size,\n            height: size,\n            mipmapped: false\n        )\n        \n        guard let texture = device.makeTexture(descriptor: textureDescriptor) else {\n            fatalError(\"Failed to create texture\")\n        }\n        \n        var data = [UInt8](repeating: 0, count: size * size * 4)\n        let center = Float(size) / 2.0\n        \n        for y in 0..<size {\n            for x in 0..<size {\n                let dx = Float(x) - center\n                let dy = Float(y) - center\n                let distance = sqrt(dx * dx + dy * dy) / center\n                let t = max(0, min(1, 1 - distance))\n                \n                let color = mix(edgeColor, centerColor, t)\n                let index = (y * size + x) * 4\n                \n                data[index] = UInt8(color.x * 255)\n                data[index + 1] = UInt8(color.y * 255)\n                data[index + 2] = UInt8(color.z * 255)\n                data[index + 3] = UInt8(color.w * 255)\n            }\n        }\n        \n        let region = MTLRegion(origin: MTLOrigin(x: 0, y: 0, z: 0), size: MTLSize(width: size, height: size, depth: 1))\n        texture.replace(region: region, mipmapLevel: 0, withBytes: data, bytesPerRow: size * 4)\n        \n        return texture\n    }\n    \n    private func createCloudTexture(color: SIMD4<Float>) -> MTLTexture {\n        // Create a cloudy/wispy texture using Perlin noise\n        let size = 64\n        let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(\n            pixelFormat: .rgba8Unorm,\n            width: size,\n            height: size,\n            mipmapped: false\n        )\n        \n        guard let texture = device.makeTexture(descriptor: textureDescriptor) else {\n            fatalError(\"Failed to create texture\")\n        }\n        \n        var data = [UInt8](repeating: 0, count: size * size * 4)\n        let noise = GKPerlinNoiseSource(frequency: 0.1, octaveCount: 3, persistence: 0.5, lacunarity: 2.0, seed: 42)\n        let noiseMap = GKNoiseMap(noise, size: vector_double2(64, 64), origin: vector_double2(0, 0), sampleCount: vector_int2(64, 64), seamless: true)\n        \n        for y in 0..<size {\n            for x in 0..<size {\n                let noiseValue = noiseMap.value(at: vector_int2(Int32(x), Int32(y)))\n                let alpha = max(0, min(1, (noiseValue + 1) / 2)) * color.w\n                let index = (y * size + x) * 4\n                \n                data[index] = UInt8(color.x * 255)\n                data[index + 1] = UInt8(color.y * 255)\n                data[index + 2] = UInt8(color.z * 255)\n                data[index + 3] = UInt8(alpha * 255)\n            }\n        }\n        \n        let region = MTLRegion(origin: MTLOrigin(x: 0, y: 0, z: 0), size: MTLSize(width: size, height: size, depth: 1))\n        texture.replace(region: region, mipmapLevel: 0, withBytes: data, bytesPerRow: size * 4)\n        \n        return texture\n    }\n    \n    private func createStarTexture(color: SIMD4<Float>) -> MTLTexture {\n        // Create a star-shaped texture for sparks\n        let size = 32\n        let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(\n            pixelFormat: .rgba8Unorm,\n            width: size,\n            height: size,\n            mipmapped: false\n        )\n        \n        guard let texture = device.makeTexture(descriptor: textureDescriptor) else {\n            fatalError(\"Failed to create texture\")\n        }\n        \n        var data = [UInt8](repeating: 0, count: size * size * 4)\n        let center = Float(size) / 2.0\n        \n        for y in 0..<size {\n            for x in 0..<size {\n                let dx = Float(x) - center\n                let dy = Float(y) - center\n                let distance = sqrt(dx * dx + dy * dy)\n                let angle = atan2(dy, dx)\n                \n                // Create star pattern\n                let rays = 6\n                let rayIntensity = abs(sin(angle * Float(rays))) * 0.5 + 0.5\n                let intensity = max(0, min(1, (1 - distance / center) * rayIntensity))\n                \n                let index = (y * size + x) * 4\n                \n                data[index] = UInt8(color.x * intensity * 255)\n                data[index + 1] = UInt8(color.y * intensity * 255)\n                data[index + 2] = UInt8(color.z * intensity * 255)\n                data[index + 3] = UInt8(color.w * intensity * 255)\n            }\n        }\n        \n        let region = MTLRegion(origin: MTLOrigin(x: 0, y: 0, z: 0), size: MTLSize(width: size, height: size, depth: 1))\n        texture.replace(region: region, mipmapLevel: 0, withBytes: data, bytesPerRow: size * 4)\n        \n        return texture\n    }\n    \n    private func createFoamyTexture(color: SIMD4<Float>) -> MTLTexture {\n        // Create a foamy texture with bubbles\n        let size = 64\n        let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(\n            pixelFormat: .rgba8Unorm,\n            width: size,\n            height: size,\n            mipmapped: false\n        )\n        \n        guard let texture = device.makeTexture(descriptor: textureDescriptor) else {\n            fatalError(\"Failed to create texture\")\n        }\n        \n        var data = [UInt8](repeating: 0, count: size * size * 4)\n        \n        // Generate random bubbles\n        for _ in 0..<20 {\n            let centerX = Int.random(in: 0..<size)\n            let centerY = Int.random(in: 0..<size)\n            let radius = Float.random(in: 3...8)\n            \n            for y in 0..<size {\n                for x in 0..<size {\n                    let dx = Float(x - centerX)\n                    let dy = Float(y - centerY)\n                    let distance = sqrt(dx * dx + dy * dy)\n                    \n                    if distance <= radius {\n                        let intensity = 1 - distance / radius\n                        let index = (y * size + x) * 4\n                        \n                        let currentAlpha = Float(data[index + 3]) / 255.0\n                        let newAlpha = max(currentAlpha, intensity * color.w)\n                        \n                        data[index] = UInt8(color.x * 255)\n                        data[index + 1] = UInt8(color.y * 255)\n                        data[index + 2] = UInt8(color.z * 255)\n                        data[index + 3] = UInt8(newAlpha * 255)\n                    }\n                }\n            }\n        }\n        \n        let region = MTLRegion(origin: MTLOrigin(x: 0, y: 0, z: 0), size: MTLSize(width: size, height: size, depth: 1))\n        texture.replace(region: region, mipmapLevel: 0, withBytes: data, bytesPerRow: size * 4)\n        \n        return texture\n    }\n    \n    private func createWakeTexture(color: SIMD4<Float>) -> MTLTexture {\n        // Create an elongated wake texture\n        let width = 32\n        let height = 8\n        let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(\n            pixelFormat: .rgba8Unorm,\n            width: width,\n            height: height,\n            mipmapped: false\n        )\n        \n        guard let texture = device.makeTexture(descriptor: textureDescriptor) else {\n            fatalError(\"Failed to create texture\")\n        }\n        \n        var data = [UInt8](repeating: 0, count: width * height * 4)\n        let centerY = Float(height) / 2.0\n        \n        for y in 0..<height {\n            for x in 0..<width {\n                let dy = abs(Float(y) - centerY) / centerY\n                let dx = Float(x) / Float(width)\n                \n                let intensity = (1 - dy) * (1 - dx) * 0.8\n                let index = (y * width + x) * 4\n                \n                data[index] = UInt8(color.x * 255)\n                data[index + 1] = UInt8(color.y * 255)\n                data[index + 2] = UInt8(color.z * 255)\n                data[index + 3] = UInt8(color.w * intensity * 255)\n            }\n        }\n        \n        let region = MTLRegion(origin: MTLOrigin(x: 0, y: 0, z: 0), size: MTLSize(width: width, height: height, depth: 1))\n        texture.replace(region: region, mipmapLevel: 0, withBytes: data, bytesPerRow: width * 4)\n        \n        return texture\n    }\n}\n\n// MARK: - Supporting Structures\n\nstruct Particle {\n    var position: SIMD3<Float>\n    var velocity: SIMD3<Float>\n    var life: Float\n    var maxLife: Float\n    var size: Float\n    var color: SIMD4<Float>\n    var type: UInt32\n    var active: UInt32\n}\n\nstruct ParticleEmitter {\n    let id: UUID\n    let type: ParticleType\n    var position: SIMD3<Float>\n    var emissionRate: Float\n    var particleLifetime: Float\n    var initialVelocity: SIMD3<Float>\n    var velocityVariation: SIMD3<Float>\n    var size: Float\n    var sizeVariation: Float\n    var color: SIMD4<Float>\n    var colorVariation: SIMD4<Float>\n    var isActive: Bool = true\n    \n    init(id: UUID, type: ParticleType, position: SIMD3<Float>, emissionRate: Float, particleLifetime: Float, initialVelocity: SIMD3<Float>, velocityVariation: SIMD3<Float>, size: Float, sizeVariation: Float, color: SIMD4<Float>, colorVariation: SIMD4<Float>) {\n        self.id = id\n        self.type = type\n        self.position = position\n        self.emissionRate = emissionRate\n        self.particleLifetime = particleLifetime\n        self.initialVelocity = initialVelocity\n        self.velocityVariation = velocityVariation\n        self.size = size\n        self.sizeVariation = sizeVariation\n        self.color = color\n        self.colorVariation = colorVariation\n    }\n}\n\nstruct EmitterData {\n    var position: SIMD3<Float>\n    var velocity: SIMD3<Float>\n    var emissionRate: Float\n    var particleLifetime: Float\n    var size: Float\n    var color: SIMD4<Float>\n    var type: UInt32\n    var active: UInt32\n}\n\nstruct ParticleUniforms {\n    var viewMatrix: matrix_float4x4\n    var projectionMatrix: matrix_float4x4\n    var cameraPosition: SIMD3<Float>\n    var deltaTime: Float\n    var time: Float\n}\n\nenum ParticleType: Int, CaseIterable {\n    case water = 0\n    case smoke = 1\n    case steam = 2\n    case spark = 3\n    case foam = 4\n    case wake = 5\n}\n\nenum WeatherType {\n    case rain\n    case fog\n    case storm\n}\n\n// MARK: - Utility Functions\n\nfunc mix<T: SIMDScalar>(_ a: SIMD4<T>, _ b: SIMD4<T>, _ t: T) -> SIMD4<T> where T: FloatingPoint {\n    return a * (1 - t) + b * t\n}